#!/usr/bin/env python

"""usage: Evershare source [destination]

If source a file, conversion from ENEX will be performed to destination.
A source of '-' will be accepted as an alias for standard input.
If no destination is given, standard output will be used.
A destination of '-' will be accepted as an alias for standard output.
If provided, destination must be the same type as source.
E.g. Evershare source.enex /some/dir is an error!

"""


__author__ = "Terry Mathew Poulin <BigBoss1964@gmail.com>"
__copyright__ = """
Copyright (c) 2013-current, Terry Mathew Poulin <BigBoss1964@gmail.com>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must
     not claim that you wrote the original software. If you use this
     software in a product, an acknowledgment in the product
     documentation would be appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must
     not be misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
"""
__license__ = "zlib"
__version__ = "0alpha"


import errno
import logging
import os.path
import subprocess
import sys
from xdg.BaseDirectory import xdg_cache_home
import xml.etree.ElementTree as et

try:
    import html2text
except:
    logging.warning("Unable to load html2text. Text conversion will be impossible!")


class Formats: #{{{
    HTML = "html"
    TEXT = "txt"
    DEFAULT = HTML
#}}}


def nl(to=sys.stdout): #{{{
    to.write("\n")
#}}}


def auto_map(formatter, mapper): #{{{
    """Provide formatter.mappings for all public methods of mapper.

    """

    if formatter is None:
        return

    for attr in dir(mapper):
        if attr.startswith('_'):
            continue
        func = getattr(mapper, attr)
        formatter.mappings[attr] = func
        logging.debug("mappings made for <%s> tags", attr)
        if attr.find('_') != -1:
            alias = attr.replace('_', '-')
            formatter.mappings[alias] = func
            logging.debug("mappings made for <%s> tags", alias)
#}}}


class TextFormatter: #{{{
    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        title = self.enex.title()
        to.write(title)
        to.write("\n")
        to.write('-' * len(title))
        to.write("\n\n")

        doc = et.fromstring(self.enex.content().encode("ascii", 'replace'))

        h = html2text.HTML2Text()
        h.ignore_links = False
        to.write(h.handle(et.tostring(doc, 'utf-8', 'html')))
    #}}}
#}}}


class HtmlFormatter: #{{{
    """Format provided EnexFile as HTML.

    You can control the mapping of specific tags within the ENEX note/content
    by setting the a dictionary key in the 'mappings' field like so:

        def en_todo(element):
            return element # nop

        f = HtmlFormatter(your_enex)
        f.mappings['en-todo'] =  en_todo

    """

    mappings = {}

    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        to.write("<!DOCTYPE HTML>")
        html = et.Element('html')
        doc = et.ElementTree(html)
        et.SubElement(html, 'head')
        body = et.SubElement(html, 'body')

        # handles replacing things like &nbsp;
        content = et.fromstring(self.enex.content().encode('utf-8', 'replace'))

        if len(self.mappings) > 0:
            self._remap(content)

        body.append(content)
        doc.write(to)
        nl(to)
    #}}}


    def _remap(self, top): #{{{
        """Handles remapping for self.mappings.

        @param top the top Element to process for remapping.
        """

        tree = et.ElementTree(top)
        parent_map = {c:p for p in tree.iter() for c in p}

        for tag in self.mappings:
            func = self.mappings[tag]

            for element in top.iter(tag):
                e = func(element)
                if e is not element:
                    # we have to go find the damn and replace it by index!
                    p = parent_map[element]
                    idx = 0
                    for peer in p.iter():
                        idx += 1
                        if peer is element:
                            break
                    p.insert(idx, e)
                    p.remove(element)
    #}}}
#}}}


class HtmlMapper: #{{{
    """This class may be used with HtmlFormatter.mappings.

    It provides sane mappings for some of Evernote's XML tags to HTML. Just
    create an instance of this class and store references to its methods in the
    appropriate keys.

    """

    def __init__(self, formatter=None): #{{{
        """Constructor. Can initialize formatter with self.


        """

        auto_map(formatter, self)
    #}}}


    def en_todo(self, e, useRealCheckBox=False): #{{{
        """Convert <en-todo> checkboxes to HTML.

        The useRealCheckBox paramater can be set to True in order to generate a
        <input/> based checkbox. The default (False) is to use a plain text
        representation.

        GIVEN:
            <en-todo checked="true" />
            <en-todo checked="false" />

        DESIRED:
            <span checked="true">[x] </span>   OR  <input type="checkbox" readonly checked />
            <span checked="false">[ ] </span>  OR  <input type="checkbox" readonly />

        """
        logging.info("FOUND en_todo(e => {0})".format(e))


        r = e
        checked = e.attrib['checked']
        assert checked in ('true', 'false')

        if useRealCheckBox:
            r = et.Element('input')
            r.attrib['type'] = 'checkbox'
            r.attrib['checked'] = checked
        else:
            r = et.Element('span')

            if checked == 'true':
                r.text = '[x] '
            elif checked == 'false':
                r.text = '[ ] '

        if r is not e:
            r.tail = e.tail
        return r
    #}}}
#}}}


class EnexFile: #{{{

    def __init__(self, path):
        logging.info("Process %s", path)
        self.root = et.parse(path)
        if not self._assert():
            raise RuntimeError("{0}: invalid format.")

    def _assert(self): #{{{
        """ Assert that the format is correct.
        """

        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.debug(et.dump(self.root))

        if self.root.getroot().tag != "en-export" or None in (
               self.root.find("./note/title"),
               self.root.find("./note/content"),
               self.root.find("./note/created"),
               self.root.find("./note/note-attributes"),
           ):
            return False

        return True
    #}}}


    def title(self): #{{{
        """Returns /en-export/note/title
        """

        return self.root.find("./note/title").text
    #}}}


    def content(self): #{{{
        """Returns /en-export/note/content
        """

        return self.contentNode().text
    #}}}

    def contentNode(self): #{{{
        return self.root.find("./note/content")
    #}}}

#}}}


class Notebook: #{{{
    def __init__(self, root): #{{{
        if not os.path.isdir(root):
            raise ValueError("{0}: not a directory.".format(root))
        logging.debug('Notebook("{0}")'.format(root))

        # check for stacks.

    #}}}
#}}}


def sync(source, dest): #{{{
    """Sync data from source to dest.

    This is implemented using rsync but technically could do whatever.
    """

    logging.debug("sync( source => {0}, dest => {1})".format(source, dest))
    subprocess.check_call(['rsync', '-rtp', '--delete', source, dest], shell=False)
#}}}


def cache_directory(subpath=None): #{{{
    """Return the cache directory as a string.

    If subpath is given, it will be returned prefixed by the cache directory.
    """

    d = os.path.join(xdg_cache_home, "Evershare")
    if subpath is not None:
        return os.path.join(d, subpath)
    else:
        return d
#}}}


def make_directory(path): #{{{
    """Make directory from path. """

    logging.debug("make_directory(path => {0})".format(path))

    # http://stackoverflow.com/a/600612/352455
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise
#}}}

def x(): #{{{
    """
    """

#}}}


def convert_file(infile, outfile, format=Formats.DEFAULT): #{{{
    """Convert from ENEX infile to OUTFILE.

    The default format is Formats.DEFAULT.
    """

    logging.info("Convert {0} to {1}".format(infile, outfile))
    logging.info("format={0}".format(format))

    enex = EnexFile(infile)

    f = None
    if format == Formats.HTML:
        f = HtmlFormatter(enex)
        HtmlMapper(f)
    elif format == Formats.TEXT:
        f = TextFormatter(enex)
    else:
        raise ValueError("Unsupported format: {0}".format(format))

    f.write(outfile)
#}}}


def convert_directory(indir, outdir, format=Formats.DEFAULT): #{{{
    """Convert ENEX file hierarchy at in formatted files in outdir.

    The default format is Formats.DEAFULT.
    """

    logging.info("Convert {0} to {1}".format(indir, outdir))
    logging.info("format={0}".format(format))

    cache_dir = cache_directory()

    logging.debug("Creating cache at {0}".format(cache_dir))
    make_directory(cache_dir)
    sync(indir, cache_dir)

    notebooks = []

    for d in os.listdir(cache_dir):
        notebook_dir = os.path.join(cache_dir, d)
        if notebook_dir.endswith(" Stack"):
            # not pretty but no sub stacking, so ;).
            #
            for notebook_in_stack in os.listdir(notebook_dir):
                notebooks.append(Notebook(os.path.join(notebook_dir, notebook_in_stack)))
        else:
            notebooks.append(Notebook(notebook_dir))

    logging.critical("Not implemented yet.")
    return 127
#}}}


def usage(): #{{{
    """Display command line usage."""

    print(__doc__)
#}}}


def guess_format(name): #{{{
    n = name.lower()
    if n.endswith('.html') or n.endswith('.xhtml'):
        return Formats.HTML

    for ext in ('.txt', '.text', '.md', '.markdown'):
        if n.endswith(ext):
            return Formats.TEXT

    return Formats.DEFAULT
#}}}


def main(args): #{{{
    """Main entry point."""

    logging.getLogger().setLevel(logging.DEBUG)
    # logging.getLogger().setLevel(logging.INFO)
    args_length = len(args)

    if args_length == 0 or args_length > 2:
        usage()
        return 0

    source = args[0]
    dest = '-'
    if args_length == 2:
        dest = args[1]

    logging.info("source is %s", source)
    logging.info("dest is %s", dest)

    if source != '-':
        if os.path.isdir(source) and not os.path.isdir(dest):
            usage()
            return 1
    if (os.path.isfile(source) or source == '-') and os.path.isdir(dest):
        usage()
        return 2

    if os.path.isdir(source):
        convert_directory(source, dest)
    else:
        if source == '-':
            source = sys.stdin
        if dest == '-':
            dest = sys.stdout
        else:
            try:
                dest = open(dest, 'w')
            except IOError as ex:
                logging.critical("IOError.strerror => %s, IOError.errno => %s", ex.strerror, ex.errno)
                return ex.errno

        convert_file(source, dest, guess_format(dest.name))

    return 0
#}}}


if __name__ == "__main__": #{{{
    sys.exit(main(sys.argv[1:]))
#}}}
