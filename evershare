#!/usr/bin/env python

"""usage: Evershare source [destination]

If source a file, conversion from ENEX will be performed to destination.
A source of '-' will be accepted as an alias for standard input.
If no destination is given, standard output will be used.
A destination of '-' will be accepted as an alias for standard output.
If provided, destination must be the same type as source.
E.g. Evershare source.enex /some/dir is an error!

"""


__author__ = "Terry Mathew Poulin <BigBoss1964@gmail.com>"
__copyright__ = """
Copyright (c) 2013-current, Terry Mathew Poulin <BigBoss1964@gmail.com>

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the
use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must
     not claim that you wrote the original software. If you use this
     software in a product, an acknowledgment in the product
     documentation would be appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must
     not be misrepresented as being the original software.

  3. This notice may not be removed or altered from any source
     distribution.
"""
__license__ = "zlib"
__version__ = "0alpha"


import errno
import logging
import os.path
import subprocess
import sys
from xdg.BaseDirectory import xdg_cache_home
import xml.etree.ElementTree as et

try:
    import html2text
except:
    logging.warning("Unable to load html2text. Text conversion will be impossible!")

try:
    # python 2
    import anydbm as dbm
except:
    # python 3
    import dbm

class Formats: #{{{
    HTML = "html"
    TEXT = "txt"
    DEFAULT = HTML
#}}}


def nl(to=sys.stdout): #{{{
    to.write("\n")
#}}}


def auto_map(formatter, mapper): #{{{
    """Provide formatter.mappings for all public methods of mapper.

    """

    if formatter is None:
        return

    for attr in dir(mapper):
        if attr.startswith('_'):
            continue
        func = getattr(mapper, attr)
        formatter.mappings[attr] = func
        logging.debug("mappings made for <%s> tags", attr)
        if attr.find('_') != -1:
            alias = attr.replace('_', '-')
            formatter.mappings[alias] = func
            logging.debug("mappings made for <%s> tags", alias)
#}}}


class TextFormatter: #{{{
    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        title = self.enex.title()
        to.write(title)
        to.write("\n")
        to.write('-' * len(title))
        to.write("\n\n")

        doc = et.fromstring(self.enex.content().encode("ascii", 'replace'))

        h = html2text.HTML2Text()
        h.ignore_links = False
        to.write(h.handle(et.tostring(doc, 'utf-8', 'html')))
    #}}}
#}}}


class HtmlFormatter: #{{{
    """Format provided EnexFile as HTML.

    You can control the mapping of specific tags within the ENEX note/content
    by setting the a dictionary key in the 'mappings' field like so:

        def en_todo(element):
            return element # nop

        f = HtmlFormatter(your_enex)
        f.mappings['en-todo'] =  en_todo

    """

    mappings = {}

    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        to.write("<!DOCTYPE HTML>")
        html = et.Element('html')
        doc = et.ElementTree(html)
        et.SubElement(html, 'head')
        body = et.SubElement(html, 'body')

        # handles replacing things like &nbsp;
        content = self.enex.to_note()

        if len(self.mappings) > 0:
            self._remap(content)

        body.append(content.getroot())
        doc.write(to)
        nl(to)
    #}}}


    def _remap(self, top): #{{{
        """Handles remapping for self.mappings.

        @param top the top Element to process for remapping.
        """

        # tree = et.ElementTree(top)
        parent_map = {c:p for p in top.iter() for c in p}

        for tag in self.mappings:
            func = self.mappings[tag]

            for element in top.iter(tag):
                e = func(element, top)
                if e is not element:
                    # we have to go find the damn and replace it by index!
                    p = parent_map[element]
                    idx = 0
                    for peer in p.iter():
                        idx += 1
                        if peer is element:
                            break
                    p.insert(idx, e)
                    p.remove(element)
    #}}}
#}}}


class HtmlMapper: #{{{
    """This class may be used with HtmlFormatter.mappings.

    It provides sane mappings for some of Evernote's XML tags to HTML. Just
    create an instance of this class and store references to its methods in the
    appropriate keys.

    """

    def __init__(self, formatter=None, crosslink_db_handle=None): #{{{
        """Constructor. Can initialize formatter with self.


        """

        self.enex = formatter.enex
        self.path = self.enex.path
        self.db = crosslink_db_handle
        auto_map(formatter, self)
    #}}}


    def en_todo(self, e, root, useRealCheckBox=False): #{{{
        """Convert <en-todo> checkboxes to HTML.

        The useRealCheckBox paramater can be set to True in order to generate a
        <input/> based checkbox. The default (False) is to use a plain text
        representation.

        GIVEN:
            <en-todo checked="true" />
            <en-todo checked="false" />

        DESIRED:
            <span checked="true">[x] </span>   OR  <input type="checkbox" readonly checked />
            <span checked="false">[ ] </span>  OR  <input type="checkbox" readonly />

        """
        logging.debug("FOUND en_todo(e => {0})".format(e))


        r = e

        #
        # Sometimes we get an empty <en-todo> tag. We can safely write these
        # out as unchecked as far as I know.
        #
        if not e.attrib.has_key('checked'):
            logging.warning("<en-todo> in {0} missing checked attribute.".format(root.path))
            e.attrib['checked'] = 'false'
        checked = e.attrib['checked']
        assert checked in ('true', 'false')

        if useRealCheckBox:
            r = et.Element('input')
            r.attrib['type'] = 'checkbox'
            r.attrib['checked'] = checked
        else:
            r = et.Element('span')

            if checked == 'true':
                r.text = '[x] '
            elif checked == 'false':
                r.text = '[ ] '

        if r is not e:
            r.tail = e.tail
        return r
    #}}}


    def a(self, e, root): #{{{
        """Convert <a> anchors with optional evernote:// rewriting.

        GIVEN:
            <a ... href="..." ...>...</a>
            <a ... href="evernote://..." ...>note</a>

        DESIRED:
            <a ... href="..." ...>...</a>
            <a ... href="relpath/to/note.html" ...>...</a>

        """
        if not e.attrib.has_key('href'):
            logging.warning("<a> has no href element: text is '{0}'".format(e.text))
            return
        if not e.attrib['href'].startswith('evernote://'):
            return e

        logging.debug("FOUND a(e => {0})".format(e))
        logging.debug("parent of this element => {0}".format(type(root)))
        target = ''.join(e.itertext())
        logging.debug("e.text => |{0}|".format(e.text))
        logging.debug("target of e => |{0}|".format(target))

        path, url = info_for_evernote_url(target, self.db)

        logging.debug("evernote:// of this a is => |{0}|".format((path, url)))
        logging.debug("e.href => |{0}|".format(e.attrib['href']))

        #
        # For some reason relpath gets this WRONG and replaces the top level
        # Evershare with an extra '..' up. If we wanted absolute path we could
        # just use 'path' as is but a relative path is more web server
        # friendly.
        #
        # So for now, just strip off the first '../'.
        #
        e.attrib['href'] = "{0}.html".format(os.path.relpath(cache_directory(path), self.path))[3:]
        # e.attrib['href'] = "{0}.html".format(cache_directory(path))

        logging.debug("new e.href => |{0}|".format(e.attrib['href']))

        return e
    #}}}


#}}}

def info_for_evernote_url(name, crosslink_db_handle): #{{{
    db = crosslink_db_handle
    for k in db.keys():
        # print("{0}.endswith({1}) == {2}".format(name,k,name.endswith(k)))
        # if name.endswith(k):
        if k.endswith(name):
            return (k, db[k])
    return (name, '')
#}}}


class EnNote(et.ElementTree): #{{{

    def __init__(self, doctext, path=""): #{{{
        self.path = path

        # OK, here's some fugly hackoliciousness. Chainsaw kludge afoot.
        try:
            kill = {
                '&nbsp;':u'\xc2\xA0', '&160;':u'\xc2\xA0',
                '&hellip;' : u'\xE2\x80\xA6', # broken html (... as one symbol).
                '&laquo;' : u'\xAB', # << as one symbol.
            }
            s = doctext
            for wtf, r in kill.items():
                s = s.replace(wtf, r)
            s = s.encode('utf-8', 'replace')

            try:
                super(EnNote, self).__init__(et.XML(s, et.XMLParser(1)))
            except et.ParseError as ex:
                logging.error(ex)
                logging.error("EnNote doctext=>{0}".format(doctext))
                raise ex
        except UnicodeEncodeError as ex:
            logging.critical("Bloody unicode error!")
            n = 10
            logging.critical(doctext[ex.start-n:ex.start-1]+"|"+doctext[ex.start:ex.end]+"|"+doctext[ex.end+1:ex.end+n])
            # sys.exit(0)
    #}}}


    def get_evernote_url(self, crosslink_db_handle): #{{{
        """Return my evernote:// in crosslink_db or ''."""

        # Strip the extension off.
        n = os.path.splitext(self.path)[0]

        return info_for_evernote_url(n, db)
    #}}}

#}}}


class EnexFile: #{{{

    def __init__(self, path):
        logging.debug("Process %s", path)
        self.path = path
        self.root = et.parse(self.path)
        if not self._assert():
            raise RuntimeError("{0}: invalid format.")

    def _assert(self): #{{{
        """ Assert that the format is correct.
        """

        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.debug(et.dump(self.root))

        if self.root.getroot().tag != "en-export" or None in (
               self.root.find("./note/title"),
               self.root.find("./note/content"),
               self.root.find("./note/created"),
               self.root.find("./note/note-attributes"),
           ):
            return False

        return True
    #}}}


    def title(self): #{{{
        """Returns /en-export/note/title
        """

        return self.root.find("./note/title").text
    #}}}


    def content(self): #{{{
        """Returns /en-export/note/content
        """

        return self.contentNode().text
    #}}}

    def contentNode(self): #{{{
        return self.root.find("./note/content")
    #}}}

    def to_note(self): #{{{
        """Converts this EnexFile to an EnNote.
        """

        return EnNote(self.content(), self.path)
    #}}}


    def to_format(self, format, crosslink_db_handle): #{{{
        db = crosslink_db_handle
        logging.debug("self.path=>{0}".format(self.path))

        outfile = "{0}.{1}".format(os.path.splitext(self.path)[0], format)
        logging.debug("outfile=>{0}".format(outfile))

        with open(outfile, 'w') as  outstream:
            convert_file(self.path, outstream, format, db)
    #}}}

#}}}


class Notebook: #{{{
    notes = []

    def __init__(self, root): #{{{
        self.dir = root
        if not os.path.isdir(self.dir):
            raise ValueError("{0}: not a directory.".format(self.dir))
        logging.debug('Notebook("{0}")'.format(self.dir))

        # check for stacks.
        for name in os.listdir(self.dir):
            if name.endswith(".enex"):
                p = os.path.join(self.dir, name)
                logging.debug("adding {0} to self.notes.".format(p))
                self.notes.append(EnexFile(p))
    #}}}
#}}}


def sync(source, dest): #{{{
    """Sync data from source to dest.

    This is implemented using rsync but technically could do whatever.
    """

    logging.debug("sync( source => {0}, dest => {1})".format(source, dest))
    subprocess.check_call(['rsync', '-rtp', '--delete', source, dest], shell=False)
#}}}


def cache_directory(subpath=None): #{{{
    """Return the cache directory as a string.

    If subpath is given, it will be returned prefixed by the cache directory.
    """

    d = os.path.join(xdg_cache_home, "Evershare")
    if subpath is not None:
        return "{0}/{1}".format(d, subpath)
    else:
        return d
#}}}


def make_directory(path): #{{{
    """Make directory from path. """

    logging.debug("make_directory(path => {0})".format(path))

    # http://stackoverflow.com/a/600612/352455
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise
#}}}


def find(base, name): #{{{
    """Quick hack that works like find ${base} -name \*${name}\*.

    Returns a list of matches.
    """
    r = []
    for root, dirs, files in os.walk(base):
        logging.debug("root => {0}".format(root))
        logging.debug("dirs => {0}".format(dirs))
        logging.debug("files => {0}".format(files))
        for file_name in files:
            if file_name.find(name) != -1:
                r.append(os.path.join(root, file_name))
    logging.debug("r => {0}".format(r))
    return r
#}}}


def convert_file(infile, outfile, format=Formats.DEFAULT, crosslink_db_handle=None): #{{{
    """Convert from ENEX infile to OUTFILE.
The default format is Formats.DEFAULT.  """

    logging.info("Convert {0} to {1}".format(infile, outfile))
    logging.info("format={0}".format(format))

    enex = EnexFile(infile)

    f = None
    if format == Formats.HTML:
        f = HtmlFormatter(enex)
        HtmlMapper(f, crosslink_db_handle)
    elif format == Formats.TEXT:
        f = TextFormatter(enex)
    else:
        raise ValueError("Unsupported format: {0}".format(format))

    f.write(outfile)
#}}}


CROSSLINK_DB = cache_directory("crosslink.dbm")

def build_crosslink_db(notebooks): #{{{
    """Populate CROSSLINK_DB from table.

    @param notebooks is a list of notebooks.

    CROSSLINK_DB is populated like this:

        base path = evernote://url

    Base path is like /Notebook/Note Name.
    No .enex at the end. No prefix before /.
    """

    logging.info("Building cross link database.")

    # db = dbm.open(CROSSLINK_DB, 'r', 0600)
    db = None
    try:
        db = dbm.open(CROSSLINK_DB, 'n', 0600)
    except dbm.error as e:
        logging.error(e)
        sys.exit(1)

    # first pass for building paths.
    for nb in notebooks:
        for note in nb.notes:
            p = note.path.partition(cache_directory())[2] + "/"
            # XXX this should be os.path.splitext
            p = p.rsplit('.', 1)[0]
            logging.debug("base note path => {0}".format(p))
            db[p] = ""

    # second pass for building links.
    # for notebook in table.values():
    for nb in notebooks:
        for note in nb.notes:
            n = None
            try:
                n = note.to_note()
            except et.ParseError:
                logging.error("note is note.path=>{0}".format(note.path))
                continue

            # for a in n.findall(".//a[@href]"):
            for a in n.iterfind(".//a[@href]"):
                href = a.attrib['href']
                logging.debug("href => {0}".format(href))
                if href.startswith('evernote://'):
                    logging.debug("link is <{0}> with text {1} and href={2} from note {3}".format(
                                 a.tag, a.text, a.attrib['href'], note.path))
                    if a.text is None:
                        # UGH sometimes we get text like <a ...><span>text</span></a>.
                        a.text = ''.join(a.itertext())
                        # for text in a.itertext():
                            # a.text += text

                    for path in db.keys():
                        if path.endswith('/'+a.text):
                            logging.debug('db["{0}"] = {1}'.format(path, href))
                            db[path] = href
    return db
#}}}


def convert_directory(indir, outdir, format=Formats.DEFAULT): #{{{
    """Convert ENEX file hierarchy at in formatted files in outdir.

    The default format is Formats.DEAFULT.
    """

    logging.info("Convert {0} to {1}".format(indir, outdir))
    logging.info("format={0}".format(format))
    # return WIP(indir, outdir, format)

    cache_dir = cache_directory()

    logging.debug("Creating cache at {0}".format(cache_dir))
    make_directory(cache_dir)
    # make sure to add +/ so it explodes right.
    sync(indir+"/", cache_dir)

    notebooks = []

    logging.info("Building list of notebooks")
    for d in os.listdir(cache_dir):
        notebook_dir = os.path.join(cache_dir, d)
        # XXX
        if not os.path.isdir(notebook_dir): continue

        if notebook_dir.endswith(" Stack"):
            logging.debug("{0} is a Notebook stack.".format(notebook_dir))
            #
            # not pretty but no sub stacking, so ;).
            #
            for notebook_in_stack in os.listdir(notebook_dir):
                path = os.path.join(notebook_dir, notebook_in_stack)
                try: # funky error in one note out of 1100+.
                    notebooks.append(Notebook(path))
                except et.ParseError as ex:
                    logging.warning("Skipping a notebook in {0} because {1}".format(path, ex))
        else:
            notebooks.append(Notebook(notebook_dir))

    db = build_crosslink_db(notebooks)

    logging.info("Converting notebooks.")
    for nb in notebooks:
        for enex in nb.notes:
            enex.to_format(format, db)

    logging.critical("Not implemented yet.")
    return 127
#}}}
def WIP(indir, outdir, format=Formats.DEFAULT): #{{{
    """WIP test monkey stuff. """
    print("indir=>"+indir)
    print("outdir=>"+outdir)
    testfile = '/tmp/evershare.py.cache/Evershare/My Stack/Projects/SxE Game Engine.enex'
    db = dbm.open(CROSSLINK_DB, 'r')

    # with open('./test.html', 'w') as  outfile:
        # convert_file(testfile, outfile, format, db)

    enex = EnexFile(testfile)
    enex.to_format(format, db)
#}}}


def usage(): #{{{
    """Display command line usage."""

    print(__doc__)
#}}}


def guess_format(name): #{{{
    n = name.lower()
    if n.endswith('.html') or n.endswith('.xhtml'):
        return Formats.HTML

    for ext in ('.txt', '.text', '.md', '.markdown'):
        if n.endswith(ext):
            return Formats.TEXT

    return Formats.DEFAULT
#}}}


def main(args): #{{{
    """Main entry point."""

    logging.getLogger().setLevel(logging.INFO)
    # logging.getLogger().setLevel(logging.DEBUG)
    # logging.getLogger().setLevel(logging.ERROR)
    args_length = len(args)

    if args_length == 0 or args_length > 2:
        usage()
        return 0

    source = args[0]
    dest = '-'
    if args_length == 2:
        dest = args[1]

    logging.info("source is %s", source)
    logging.info("dest is %s", dest)

    if source != '-':
        if os.path.isdir(source) and not os.path.isdir(dest):
            usage()
            return 1
    if (os.path.isfile(source) or source == '-') and os.path.isdir(dest):
        usage()
        return 2

    if os.path.isdir(source):
        convert_directory(source, dest)
    else:
        if source == '-':
            source = sys.stdin
        if dest == '-':
            dest = sys.stdout
        else:
            try:
                dest = open(dest, 'w')
            except IOError as ex:
                logging.critical("IOError.strerror => %s, IOError.errno => %s", ex.strerror, ex.errno)
                return ex.errno

        convert_file(source, dest, guess_format(dest.name))

    return 0
#}}}


if __name__ == "__main__": #{{{
    sys.exit(main(sys.argv[1:]))
#}}}
