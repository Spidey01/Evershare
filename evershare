#!/usr/bin/env python
"""usage: Evershare source [destination]

If source a file, conversion from ENEX will be performed to destination.
A source of '-' will be accepted as an alias for standard input.
If no destination is given, standard output will be used.
A destination of '-' will be accepted as an alias for standard output.
If provided, destination must be the same type as source.
E.g. Evershare source.enex /some/dir is an error!

"""

import logging
import os.path
import sys
import xml.etree.ElementTree as et

try:
    import html2text
except:
    logging.warning("Unable to load html2text. Text conversion will be impossible!")


class Formats: #{{{
    HTML = "html"
    TEXT = "txt"
    DEFAULT = HTML
#}}}


def nl(to=sys.stdout): #{{{
    to.write("\n")
#}}}


def auto_map(formatter, mapper): #{{{
    """Provide formatter.mappings for all public methods of mapper.

    """

    if formatter is None:
        return

    for attr in dir(mapper):
        if attr.startswith('_'):
            continue
        func = getattr(mapper, attr)
        formatter.mappings[attr] = func
        logging.debug("mappings made for <%s> tags", attr)
        if attr.find('_') != -1:
            alias = attr.replace('_', '-')
            formatter.mappings[alias] = func
            logging.debug("mappings made for <%s> tags", alias)
#}}}


class TextFormatter: #{{{
    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        title = self.enex.title()
        to.write(title)
        to.write("\n")
        to.write('-' * len(title))
        to.write("\n\n")

        doc = et.fromstring(self.enex.content().encode("ascii", 'replace'))

        h = html2text.HTML2Text()
        h.ignore_links = False
        to.write(h.handle(et.tostring(doc, 'utf-8', 'html')))
    #}}}
#}}}


class HtmlFormatter: #{{{
    """Format provided EnexFile as HTML.

    You can control the mapping of specific tags within the ENEX note/content
    by setting the a dictionary key in the 'mappings' field like so:

        def en_todo(element):
            return element # nop

        f = HtmlFormatter(your_enex)
        f.mappings['en-todo'] =  en_todo

    """

    mappings = {}

    def __init__(self, enex): #{{{
        self.enex = enex
    #}}}


    def write(self, to): #{{{
        # to.write(self.enex.content().encode("utf-8", "xmlcharrefreplace"))
        to.write("<!DOCTYPE HTML>")
        html = et.Element('html')
        doc = et.ElementTree(html)
        et.SubElement(html, 'head')
        body = et.SubElement(html, 'body')

        content = et.fromstring(self.enex.content().encode('ascii', 'replace'))

        if len(self.mappings) > 0:
            self._remap(content)

        body.append(content)
        doc.write(to)
        nl(to)
    #}}}


    def _remap(self, top): #{{{
        """Handles remapping for self.mappings.

        @param top the top Element to process for remapping.
        """

        tree = et.ElementTree(top)
        parent_map = {c:p for p in tree.iter() for c in p}

        for tag in self.mappings:
            func = self.mappings[tag]

            for element in top.iter(tag):
                e = func(element)
                if e is not element:
                    # we have to go find the damn and replace it by index!
                    p = parent_map[element]
                    idx = 0
                    for peer in p.iter():
                        idx += 1
                        if peer is element:
                            break
                    p.insert(idx, e)
                    p.remove(element)
    #}}}
#}}}


class HtmlMapper: #{{{
    """This class may be used with HtmlFormatter.mappings.

    It provides sane mappings for some of Evernote's XML tags to HTML. Just
    create an instance of this class and store references to its methods in the
    appropriate keys.

    """

    def __init__(self, formatter=None): #{{{
        """Constructor. Can initialize formatter with self.


        """

        auto_map(formatter, self)
    #}}}


    def en_todo(self, e, useRealCheckBox=False): #{{{
        """Convert <en-todo> checkboxes to HTML.

        The useRealCheckBox paramater can be set to True in order to generate a
        <input/> based checkbox. The default (False) is to use a plain text
        representation.

        GIVEN:
            <en-todo checked="true" />
            <en-todo checked="false" />

        DESIRED:
            <span checked="true">[x] </span>   OR  <input type="checkbox" readonly checked />
            <span checked="false">[ ] </span>  OR  <input type="checkbox" readonly />

        """
        logging.info("FOUND en_todo(e => {0})".format(e))


        r = e
        checked = e.attrib['checked']
        assert checked in ('true', 'false')

        if useRealCheckBox:
            r = et.Element('input')
            r.attrib['type'] = 'checkbox'
            r.attrib['checked'] = checked
        else:
            r = et.Element('span')

            if checked == 'true':
                r.text = '[x] '
            elif checked == 'false':
                r.text = '[ ] '

        if r is not e:
            r.tail = e.tail
        return r
    #}}}
#}}}


class EnexFile: #{{{

    def __init__(self, path):
        logging.info("Process %s", path)
        self.root = et.parse(path)
        if not self._assert():
            raise RuntimeError("{0}: invalid format.")

    def _assert(self): #{{{
        """ Assert that the format is correct.
        """

        if logging.getLogger().isEnabledFor(logging.DEBUG):
            logging.debug(et.dump(self.root))

        if self.root.getroot().tag != "en-export" or None in (
               self.root.find("./note/title"),
               self.root.find("./note/content"),
               self.root.find("./note/created"),
               self.root.find("./note/note-attributes"),
           ):
            return False

        return True
    #}}}


    def title(self): #{{{
        """Returns /en-export/note/title
        """

        return self.root.find("./note/title").text
    #}}}


    def content(self): #{{{
        """Returns /en-export/note/content
        """

        return self.contentNode().text
    #}}}

    def contentNode(self): #{{{
        return self.root.find("./note/content")
    #}}}

#}}}


def convert_file(infile, outfile, format=Formats.DEFAULT): #{{{
    """Convert from ENEX infile to OUTFILE.

    The default format is Formats.DEFAULT.
    """

    logging.info("Convert {0} to {1}".format(infile, outfile))
    logging.debug("format={0}".format(format))

    enex = EnexFile(infile)

    f = None
    if format == Formats.HTML:
        f = HtmlFormatter(enex)
        HtmlMapper(f)
    elif format == Formats.TEXT:
        f = TextFormatter(enex)
    else:
        raise ValueError("Unsupported format: {0}".format(format))

    f.write(outfile)
#}}}


def convert_directory(indir, outdir, format=Formats.DEFAULT): #{{{
    """Convert ENEX file hierarchy at in formatted files in outdir.

    The default format is Formats.DEAFULT.
    """

    logging.critical("Not implemented yet.")
    return 127
#}}}

def usage(): #{{{
    """Display command line usage."""

    print(__doc__)
#}}}


def main(args): #{{{
    """Main entry point."""

    # logging.getLogger().setLevel(logging.DEBUG)
    logging.getLogger().setLevel(logging.INFO)
    args_length = len(args)

    if args_length == 0 or args_length > 2:
        usage()
        return 0

    source = args[0]
    dest = '-'
    if args_length == 2:
        dest = args[1]

    logging.info("source is %s", source)
    logging.info("dest is %s", dest)

    if source != '-':
        if os.path.isdir(source) and not os.path.isdir(dest) or dest == '-':
            usage()
            return 1
    if (os.path.isfile(source) or source == '-') and os.path.isdir(dest):
        usage()
        return 2


    if os.path.isdir(source):
        return convert_directory(source, dest)
    else:
        if source == '-':
            source = sys.stdin
        if dest == '-':
            dest = sys.stdout
        else:
            try:
                dest = open(dest, 'w')
            except IOError as ex:
                logging.critical("IOError.strerror => %s, IOError.errno => %s", ex.strerror, ex.errno)
                return ex.errno

        return convert_file(source, dest)

    # NOTREACHED
    return 100
#}}}


if __name__ == "__main__": #{{{
    sys.exit(main(sys.argv[1:]))
#}}}
